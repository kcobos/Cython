{"name":"Cython","tagline":"Comparativa de Cython y primeros pasos","body":"#Cython\r\n\r\n##¿Qué es Cython?\r\nEs un compilador basado en Pyrex.\r\nPermite crear funciones en Python y compilarlas en lenguaje objeto.\r\nTambién permite hacer llamadas a funciones de C/C++.\r\n\r\n##¿Qué ventajas tiene?\r\nAl compilar en lenguaje objeto funciones, éstas no se tienen que interpretar para ejecutarse por lo que ganamos velocidad en la ejecución de un programa.\r\nTambién podemos encapsular una aplicación hecha en C/C++ para, por ejemplo, desde Python hacerle una interfaz o pasarle datos obtenidos desde internet.\r\n\r\n##Instalación\r\n###Linux:\r\n\tsudo apt-get install cython libpython2.7-dev # Para Python2\r\n\tsudo apt-get install cython3 libpython3.4-dev # Para Python3\r\n###Windows:\r\n\tExisten múltiples opciones \r\n\t\thttps://github.com/cython/cython/wiki/InstallingOnWindows\r\n\r\n##Un ejemplo simple\r\nPara empezar vamos a hacer un ejemplo simple como puede ser la sucesión de Fibonacci de forma recursiva.\r\nVamos a crear una función de Fibonacci de tres maneras diferentes:\r\nEn Python normal\r\nEn Cython (Python compilado)\r\nEn C/C++\r\nPor último vamos a hacer una comparación de tiempos entre las distintas funciones.\r\n\r\n###Creación de ficheros\r\n####fibonacciPython.py (Python normal)\r\ndef fibonacciRec(n):\r\n\tif n==0:\r\n    \t\treturn 0\r\n\telif n==1:\r\n\t  \treturn 1\r\n\telse:\r\n\t\treturn fibonacciRec(n-2) + fibonacciRec(n-1)\r\n\r\n####fibonacciCython.pyx (Cython)\r\ndef fibonacciRec(n):\r\n\tif n==0:\r\n    \t\treturn 0\r\n\t\telif n==1:\r\n\t\t  \treturn 1\r\n\telse:\r\n\t\treturn fibonacciRec(n-2) + fibonacciRec(n-1)\r\n\r\n####fibonacci.cpp (C/C++)\r\nint fibonacciRec(int n){\r\n\tif (n==0)\r\n\t    \treturn 0;\r\n\telse if (n==1)\r\n\t    \treturn 1;\r\n\telse\r\n    \t\treturn fibonacciRec(n-2) + fibonacciRec(n-1);\r\n}\r\n\r\nextern \"C\" {\r\n    int fibonacciRecC(int n){return fibonacciRec(n);}\r\n}\r\n\r\n\r\n##Aclaraciones\r\nCython tiene la misma sintaxis que Python aunque cosas nuevas. \r\nCuidado con la extensión de los archivos!!\r\nEn C/C++, hay que especificar las funciones o las variables que tiene una vinculación externa, es decir, aquellas que queramos llamar desde Python.\r\nPara ello usamos el bloque “extern” donde dentro declaramos variables y funciones que se van a poder usar desde Python.\r\n\r\n##Compilación de Cython \r\nUna vez que tenemos los ficheros pyx (Cython) tenemos que generar su código objeto.\r\nPara ello necesitamos hacer uso de un script de configuración que lo que va a hacer es buscar todos los archivos con extensión pyx y va a generar su código objeto, un archivo con extensión so.\r\nLo único que tenemos que hacer es llamar a dicho script de la siguiente manera:\r\n\tpython setup.py build_ext --inplace #Python2\r\n\tpython3 setup.py build_ext --inplace #Python3\r\n\r\n###Script de configuración\r\nfrom distutils.core import setup\r\nfrom Cython.Build import cythonize\r\nimport glob, os\r\nfiles = []\r\nos.chdir(\".\")\r\n\r\nfor file in glob.glob(\"*.pyx\"):\r\n\tfiles.append(file)\r\nsetup(\r\n\text_modules = cythonize(files)\r\n)\r\n\r\n##Uso de Cython\r\nUna vez generado el código objeto, hacer uso de las funciones que haya en el fichero .pyx\r\nPara ello necesitamos importar el módulo y ya podemos usarlas:\r\n\timport fibonacciCython #importa el archivo “fibonacciCython.so”\r\n\tprint(fibonacciCython.fibonacciRec(5)) #se hace uso de la función fibonacciRec\r\n\r\n###Compilación de C/C++ para el uso con Python \r\nUna vez creado el archivo C/C++ con las funciones que se quieran usar en Python especificadas para que se vinculen externamente, podemos proceder a compilarlo:\r\n\tg++ -c -fPIC fibonacci.cpp -o fibonacci.o\r\n\tg++ -shared -Wl,-soname,libfibonacci.so -o libfibonacci.so  fibonacci.o\r\nCon esto hemos creado el archivo .so necesario para trabajar en Python.\r\n\r\n###Uso de C/C++ en Python\r\nUna vez generado el archivo .so, en nuestro caso libfibonacci.so, podemos usar las funciones externalizadas de la siguiente manera:\r\n\tfrom ctypes import cdll #importamos cdll para cargar bibliotecas de C/C++\r\n\tlibfi = cdll.LoadLibrary('./libfibonacci.so') #cargamos la biblioteca en libfi\r\nprint(libfi.fibonacciRecC(5)) #usamos las funciones de dicha biblioteca\r\n\r\n##Comparativa de funciones\r\nPara saber si Cython realmente merece la pena, hemos comparado los tiempos de ejecución para distintos tamaños de n:\r\n| N  | Python   | Cython   | C/C++   |\r\n|----|----------|----------|---------|\r\n| 39 | 29.1104  | 18.1274  | 0.8510  |\r\n| 40 | 47.2322  | 29.4395  | 1.4826  |\r\n| 41 | 76.4090  | 47.3236  | 2.4527  |\r\n| 42 | 123.7818 | 75.5095  | 3.8937  |\r\n| 43 | 202.2534 | 123.7621 | 6.1991  |\r\n| 44 | 327.2314 | 199.7456 | 9.9453  |\r\n| 45 | 529.8116 | 364.6818 | 15.9019 |\r\n\r\n##Para terminar\r\nDesde Cython se puede hacer llamadas a funciones de C/C++:\r\ncythonC.pyx\r\n\tfrom libc.stdlib cimport atoi\r\n\tcdef parse_charptr_to_py_int(char* s):\r\n\t\tassert s is not NULL, \"string is NULL\"\r\n\t\treturn atoi(s)\r\n\tdef string_to_int(n):\r\n\t\treturn parse_charptr_to_py_int(n)\r\n\r\nUsándose de igual manera que un .pyx normal.\r\n\r\n##Enlaces de interés\r\nhttp://docs.cython.org/src/tutorial/cython_tutorial.html\r\nhttp://docs.cython.org/src/userguide/language_basics.html\r\nhttp://docs.cython.org/src/userguide/wrapping_CPlusPlus.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}