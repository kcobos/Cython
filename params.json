{"name":"Cython","tagline":"Comparativa de Cython y primeros pasos","body":"#Cython\r\n\r\n##¿Qué es Cython?\r\nEs un compilador basado en Pyrex.\r\n\r\nPermite crear funciones en Python y compilarlas en lenguaje objeto.\r\n\r\nTambién permite hacer llamadas a funciones de C/C++.\r\n\r\n##¿Qué ventajas tiene?\r\nAl compilar en lenguaje objeto funciones, éstas no se tienen que interpretar para ejecutarse por lo que ganamos velocidad en la ejecución de un programa.\r\n\r\nTambién podemos encapsular una aplicación hecha en C/C++ para, por ejemplo, desde Python hacerle una interfaz o pasarle datos obtenidos desde internet.\r\n\r\n##Instalación\r\n###Linux:\r\n\tsudo apt-get install cython libpython2.7-dev # Para Python2\r\n\tsudo apt-get install cython3 libpython3.4-dev # Para Python3\r\n###Windows:\r\n\tExisten múltiples opciones \r\n\t\thttps://github.com/cython/cython/wiki/InstallingOnWindows\r\n\r\n##Un ejemplo simple\r\nPara empezar vamos a hacer un ejemplo simple como puede ser la sucesión de Fibonacci de forma recursiva.\r\nVamos a crear una función de Fibonacci de tres maneras diferentes:\r\n* En Python normal\r\n* En Cython (Python compilado)\r\n* En C/C++\r\nPor último vamos a hacer una comparación de tiempos entre las distintas funciones.\r\n\r\n###Creación de ficheros\r\n####fibonacciPython.py (Python normal)\r\n    def fibonacciRec(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return 1\r\n        else:\r\n            return fibonacciRec(n-2) + fibonacciRec(n-1)\r\n\r\n####fibonacciCython.pyx (Cython)\r\n    def fibonacciRec(n):\r\n        if n==0:\r\n            return 0\r\n        elif n==1:\r\n            return 1\r\n        else:\r\n            return fibonacciRec(n-2) + fibonacciRec(n-1)\r\n\r\n####fibonacci.cpp (C/C++)\r\n```cpp\r\n    int fibonacciRec(int n){\r\n        if (n==0)\r\n            return 0;\r\n        else if (n==1)\r\n            return 1;\r\n        else\r\n            return fibonacciRec(n-2) + fibonacciRec(n-1);\r\n    }\r\n\r\n    extern \"C\" {\r\n        int fibonacciRecC(int n){return fibonacciRec(n);}\r\n    }\r\n```\r\n\r\n##Aclaraciones\r\nCython tiene la misma sintaxis que Python aunque cosas nuevas. \r\n\r\nCuidado con la extensión de los archivos!!\r\n\r\nEn C/C++, hay que especificar las funciones o las variables que tiene una vinculación externa, es decir, aquellas que queramos llamar desde Python.\r\n\r\nPara ello usamos el bloque “extern” donde dentro declaramos variables y funciones que se van a poder usar desde Python.\r\n\r\n##Compilación de Cython \r\nUna vez que tenemos los ficheros pyx (Cython) tenemos que generar su código objeto.\r\n\r\nPara ello necesitamos hacer uso de un script de configuración que lo que va a hacer es buscar todos los archivos con extensión pyx y va a generar su código objeto, un archivo con extensión so.\r\n\r\n####Lo único que tenemos que hacer es llamar a dicho script de la siguiente manera:\r\n\tpython setup.py build_ext --inplace #Python2\r\n\tpython3 setup.py build_ext --inplace #Python3\r\n\r\n###Script de configuración\r\n    from distutils.core import setup\r\n    from Cython.Build import cythonize\r\n    import glob, os\r\n    files = []\r\n    os.chdir(\".\")\r\n\r\n    for file in glob.glob(\"*.pyx\"):\r\n        files.append(file)\r\n    \r\n    setup(\r\n        ext_modules = cythonize(files)\r\n    )\r\n\r\n##Uso de Cython\r\nUna vez generado el código objeto, hacer uso de las funciones que haya en el fichero .pyx\r\n####Para ello necesitamos importar el módulo y ya podemos usarlas:\r\n\timport fibonacciCython #importa el archivo “fibonacciCython.so”\r\n\tprint(fibonacciCython.fibonacciRec(5)) #se hace uso de la función fibonacciRec\r\n\r\n###Compilación de C/C++ para el uso con Python \r\n####Una vez creado el archivo C/C++ con las funciones que se quieran usar en Python especificadas para que se vinculen externamente, podemos proceder a compilarlo:\r\n\tg++ -c -fPIC fibonacci.cpp -o fibonacci.o\r\n\tg++ -shared -Wl,-soname,libfibonacci.so -o libfibonacci.so  fibonacci.o\r\nCon esto hemos creado el archivo .so necesario para trabajar en Python.\r\n\r\n###Uso de C/C++ en Python\r\n####Una vez generado el archivo .so, en nuestro caso libfibonacci.so, podemos usar las funciones externalizadas de la siguiente manera:\r\n    from ctypes import cdll #importamos cdll para cargar bibliotecas de C/C++\r\n    libfi = cdll.LoadLibrary('./libfibonacci.so') #cargamos la biblioteca en libfi\r\n    print(libfi.fibonacciRecC(5)) #usamos las funciones de dicha biblioteca\r\n\r\n##Comparativa de funciones\r\n####Para saber si Cython realmente merece la pena, hemos comparado los tiempos de ejecución para distintos tamaños de n:\r\n    | N  | Python   | Cython   | C/C++   |\r\n    |----|----------|----------|---------|\r\n    | 39 | 29.1104  | 18.1274  | 0.8510  |\r\n    | 40 | 47.2322  | 29.4395  | 1.4826  |\r\n    | 41 | 76.4090  | 47.3236  | 2.4527  |\r\n    | 42 | 123.7818 | 75.5095  | 3.8937  |\r\n    | 43 | 202.2534 | 123.7621 | 6.1991  |\r\n    | 44 | 327.2314 | 199.7456 | 9.9453  |\r\n    | 45 | 529.8116 | 364.6818 | 15.9019 |\r\n\r\n![Gráfico](https://github.com/kcobos/Cython/blob/master/comparativa.png)\r\n\r\n##Para terminar\r\nDesde Cython se puede hacer llamadas a funciones de C/C++:\r\n####cythonC.pyx\r\n\tfrom libc.stdlib cimport atoi\r\n\tcdef parse_charptr_to_py_int(char* s):\r\n\t\tassert s is not NULL, \"string is NULL\"\r\n\t\treturn atoi(s)\r\n\tdef string_to_int(n):\r\n\t\treturn parse_charptr_to_py_int(n)\r\n\r\nUsándose de igual manera que un .pyx normal.\r\n\r\n##Enlaces de interés\r\n* http://docs.cython.org/src/tutorial/cython_tutorial.html\r\n* http://docs.cython.org/src/userguide/language_basics.html\r\n* http://docs.cython.org/src/userguide/wrapping_CPlusPlus.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}